#!/usr/bin/env node

/**
 * Interactive setup wizard for Spotify MCP Server
 * Guides users through the Spotify Developer app creation process
 */

import * as readline from 'readline/promises';
import { stdin as input, stdout as output } from 'process';
import { spawn } from 'child_process';
import { writeFile } from 'fs/promises';
import { homedir } from 'os';
import { join } from 'path';

// ANSI color codes for better terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  red: '\x1b[31m',
};

function print(message: string, color: string = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function header(message: string) {
  print(`\n${'='.repeat(60)}`, colors.cyan);
  print(message, colors.bright + colors.cyan);
  print('='.repeat(60), colors.cyan);
}

function success(message: string) {
  print(`âœ“ ${message}`, colors.green);
}

function error(message: string) {
  print(`âœ— ${message}`, colors.red);
}

function info(message: string) {
  print(`â„¹ ${message}`, colors.blue);
}

function warning(message: string) {
  print(`âš  ${message}`, colors.yellow);
}

async function openBrowser(url: string): Promise<void> {
  const platform = process.platform;
  let command: string;
  let args: string[];

  if (platform === 'darwin') {
    command = 'open';
    args = [url];
  } else if (platform === 'win32') {
    command = 'cmd';
    args = ['/c', 'start', '', url];
  } else {
    command = 'xdg-open';
    args = [url];
  }

  return new Promise((resolve) => {
    const child = spawn(command, args, { shell: false });

    child.on('error', () => {
      warning(`Could not open browser automatically. Please visit: ${url}`);
      resolve();
    });

    child.on('close', (code) => {
      if (code === 0) {
        success(`Opened browser to: ${url}`);
      } else {
        warning(`Could not open browser automatically. Please visit: ${url}`);
      }
      resolve();
    });
  });
}

async function prompt(rl: readline.Interface, question: string): Promise<string> {
  const answer = await rl.question(`${colors.yellow}${question}${colors.reset} `);
  return answer.trim();
}

function validateClientId(clientId: string): boolean {
  // Spotify client IDs are 32-character hex strings
  return /^[a-f0-9]{32}$/i.test(clientId);
}

function validateClientSecret(clientSecret: string): boolean {
  // Spotify client secrets are 32-character hex strings
  return /^[a-f0-9]{32}$/i.test(clientSecret);
}

async function getConfigPath(): Promise<string> {
  const platform = process.platform;
  let configPath: string;

  if (platform === 'darwin') {
    configPath = join(homedir(), 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');
  } else if (platform === 'win32') {
    configPath = join(process.env.APPDATA || join(homedir(), 'AppData', 'Roaming'), 'Claude', 'claude_desktop_config.json');
  } else {
    configPath = join(homedir(), '.config', 'Claude', 'claude_desktop_config.json');
  }

  return configPath;
}

async function createEnvFile(clientId: string, clientSecret: string): Promise<void> {
  const envContent = `# Spotify MCP Server Configuration
# Generated by setup wizard on ${new Date().toISOString()}

SPOTIFY_CLIENT_ID=${clientId}
SPOTIFY_CLIENT_SECRET=${clientSecret}
SPOTIFY_REDIRECT_URI=http://127.0.0.1:3000/callback
`;

  await writeFile('.env', envContent);
  success('Created .env file in current directory');
}

function generateMcpConfig(clientId: string, clientSecret: string, useNpx: boolean = true): string {
  if (useNpx) {
    return JSON.stringify(
      {
        mcpServers: {
          spotify: {
            command: 'npx',
            args: ['-y', '@darrenjaws/spotify-mcp'],
            env: {
              SPOTIFY_CLIENT_ID: clientId,
              SPOTIFY_CLIENT_SECRET: clientSecret,
              SPOTIFY_REDIRECT_URI: 'http://127.0.0.1:3000/callback',
            },
          },
        },
      },
      null,
      2
    );
  } else {
    return JSON.stringify(
      {
        mcpServers: {
          spotify: {
            command: 'spotify-mcp',
            env: {
              SPOTIFY_CLIENT_ID: clientId,
              SPOTIFY_CLIENT_SECRET: clientSecret,
              SPOTIFY_REDIRECT_URI: 'http://127.0.0.1:3000/callback',
            },
          },
        },
      },
      null,
      2
    );
  }
}

export async function runSetup(): Promise<void> {
  const rl = readline.createInterface({ input, output });

  try {
    header('Spotify MCP Server - Setup Wizard');
    print('\nThis wizard will help you configure the Spotify MCP Server.\n');
    info('You\'ll need to create a Spotify Developer app to get started.');

    // Step 1: Open Spotify Developer Dashboard
    header('Step 1: Create a Spotify Developer App');
    print('\n1. We\'ll open the Spotify Developer Dashboard');
    print('2. Log in with your Spotify account');
    print('3. Click "Create app" button');
    print('4. Fill in the following:');
    print('   - App name: "My Spotify MCP" (or any name you prefer)');
    print('   - App description: "MCP server for AI assistant"');
    print('   - Redirect URI: http://127.0.0.1:3000/callback');
    print('   - Which API/SDKs are you planning to use? Check "Web API"');
    print('5. Accept the terms and click "Save"\n');

    const openDashboard = await prompt(rl, 'Ready to open the Spotify Developer Dashboard? (Y/n):');
    if (openDashboard.toLowerCase() !== 'n') {
      await openBrowser('https://developer.spotify.com/dashboard');
    } else {
      info('Please visit: https://developer.spotify.com/dashboard');
    }

    print('\n');
    warning('IMPORTANT: Make sure to add this Redirect URI exactly:');
    print('  â†’ http://127.0.0.1:3000/callback', colors.bright);
    print('\n');

    await prompt(rl, 'Press ENTER once you\'ve created your app and have it open...');

    // Step 2: Get Client ID
    header('Step 2: Get Your Client ID');
    print('\nIn your Spotify app settings:');
    print('1. Look for "Client ID" (it\'s already visible)');
    print('2. Copy the 32-character code\n');

    let clientId = '';
    while (!clientId) {
      clientId = await prompt(rl, 'Paste your Client ID here:');
      if (!validateClientId(clientId)) {
        error('Invalid Client ID format. It should be a 32-character hex string.');
        clientId = '';
      } else {
        success('Client ID looks good!');
      }
    }

    // Step 3: Get Client Secret
    header('Step 3: Get Your Client Secret');
    print('\nIn your Spotify app settings:');
    print('1. Click "View client secret" link');
    print('2. Copy the secret that appears\n');

    let clientSecret = '';
    while (!clientSecret) {
      clientSecret = await prompt(rl, 'Paste your Client Secret here:');
      if (!validateClientSecret(clientSecret)) {
        error('Invalid Client Secret format. It should be a 32-character hex string.');
        clientSecret = '';
      } else {
        success('Client Secret looks good!');
      }
    }

    // Step 4: Configuration method
    header('Step 4: Choose Configuration Method');
    print('\nHow would you like to use the Spotify MCP server?\n');
    print('1. Claude Desktop (recommended for most users)');
    print('2. Claude Code CLI');
    print('3. From source (for development)\n');

    const configMethod = await prompt(rl, 'Enter your choice (1-3):');

    let mcpConfig = '';
    switch (configMethod) {
      case '1': {
        // Claude Desktop
        header('Claude Desktop Configuration');
        print('\nChoose installation method:\n');
        print('1. Using npx (recommended - no installation needed)');
        print('2. Global installation (npm install -g @darrenjaws/spotify-mcp)\n');

        const installMethod = await prompt(rl, 'Enter your choice (1-2):');
        const useNpx = installMethod !== '2';

        mcpConfig = generateMcpConfig(clientId, clientSecret, useNpx);

        const configPath = await getConfigPath();
        print('\n');
        info(`Your Claude Desktop config file should be at:`);
        print(`  ${configPath}`, colors.bright);
        print('\n');
        success('Copy this configuration and add it to your claude_desktop_config.json:');
        print('\n' + mcpConfig, colors.cyan);
        print('\n');
        warning('After updating the config, restart Claude Desktop for changes to take effect.');
        break;
      }
      case '2': {
        // Claude Code CLI
        header('Claude Code CLI Configuration');
        mcpConfig = generateMcpConfig(clientId, clientSecret, true);

        print('\n');
        info('Add this to your ~/.claude/config.json:');
        print('\n' + mcpConfig, colors.cyan);
        print('\n');
        info('Or run: claude mcp add');
        break;
      }
      case '3': {
        // Development from source
        header('Development Configuration');
        await createEnvFile(clientId, clientSecret);
        print('\n');
        success('Configuration saved!');
        print('\nNext steps:');
        print('1. Run: npm run build');
        print('2. Test with MCP Inspector: npx @modelcontextprotocol/inspector node build/index.js');
        break;
      }
      default: {
        warning('Invalid choice. Showing all configuration options...');
        print('\n=== Claude Desktop (npx) ===');
        print(generateMcpConfig(clientId, clientSecret, true), colors.cyan);
        print('\n=== Development (.env) ===');
        await createEnvFile(clientId, clientSecret);
        break;
      }
    }

    // Step 5: Test Connection (Optional)
    header('Setup Complete!');
    success('Your Spotify MCP server is configured!');
    print('\n');
    info('Next steps:');
    print('1. Restart Claude Desktop (if using desktop app)');
    print('2. Try asking Claude: "What\'s currently playing on Spotify?"');
    print('3. The first request will trigger OAuth authentication in your browser');
    print('\n');
    success('Happy listening! ðŸŽµ');

  } catch (err: any) {
    error(`Setup failed: ${err.message}`);
    process.exit(1);
  } finally {
    rl.close();
  }
}

// Run setup if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runSetup().catch((err) => {
    console.error('Setup error:', err);
    process.exit(1);
  });
}
